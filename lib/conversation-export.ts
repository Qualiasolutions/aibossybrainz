import { BOT_PERSONALITIES, type BotType } from "@/lib/bot-personalities";
import type { ChatMessage } from "@/lib/types";

/**
 * Export entire conversation to PDF
 */
export async function exportConversationToPDF(
  messages: ChatMessage[],
  chatTitle: string,
  botType: BotType,
): Promise<void> {
  const { default: html2canvas } = await import("html2canvas");
  const { default: jsPDF } = await import("jspdf");

  const personality = BOT_PERSONALITIES[botType];
  const date = new Date().toLocaleDateString();

  // Create container for rendering
  const container = document.createElement("div");
  container.style.cssText = `
    position: absolute;
    left: -9999px;
    width: 800px;
    padding: 40px;
    background: white;
    font-family: system-ui, -apple-system, sans-serif;
  `;

  // Build HTML content
  let html = `
    <div style="margin-bottom: 32px; padding-bottom: 20px; border-bottom: 2px solid #e5e5e5;">
      <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">
        ${personality.avatar ? `<img src="${personality.avatar}" style="width: 64px; height: 64px; border-radius: 50%;" crossorigin="anonymous" />` : ""}
        <div>
          <h1 style="margin: 0; font-size: 24px; color: #1a1a1a;">${chatTitle}</h1>
          <p style="margin: 4px 0 0 0; color: #666; font-size: 14px;">
            Conversation with ${personality.name} • ${date}
          </p>
        </div>
      </div>
    </div>
  `;

  // Add messages
  for (const message of messages) {
    const isUser = message.role === "user";
    const textContent = message.parts
      ?.filter((part) => part.type === "text")
      .map((part) => part.text)
      .join("\n")
      .trim();

    if (!textContent) continue;

    const msgBotType = (message.metadata?.botType as BotType) || botType;
    const msgPersonality = BOT_PERSONALITIES[msgBotType];

    html += `
      <div style="margin-bottom: 24px; padding: 16px; border-radius: 12px; background: ${isUser ? "#f5f5f5" : "#fef2f2"};">
        <div style="font-weight: 600; font-size: 14px; color: ${isUser ? "#333" : "#b91c1c"}; margin-bottom: 8px;">
          ${isUser ? "You" : msgPersonality.name}
        </div>
        <div style="line-height: 1.6; white-space: pre-wrap; color: #1a1a1a; font-size: 14px;">
          ${markdownToHtml(textContent)}
        </div>
      </div>
    `;
  }

  // Footer
  html += `
    <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e5e5; color: #999; font-size: 12px; text-align: center;">
      Generated by Alecci Media AI • ${date}
    </div>
  `;

  container.innerHTML = html;
  document.body.appendChild(container);

  // Wait for images to load
  await new Promise((resolve) => setTimeout(resolve, 500));

  try {
    const canvas = await html2canvas(container, {
      scale: 2,
      useCORS: true,
      logging: false,
    });

    // A4 dimensions in mm
    const pageWidth = 210;
    const pageHeight = 297;

    // Margins in mm
    const marginLeft = 15;
    const marginRight = 15;
    const marginTop = 20;
    const marginBottom = 20;

    // Content area dimensions
    const contentWidth = pageWidth - marginLeft - marginRight;
    const contentHeight = pageHeight - marginTop - marginBottom;

    // Calculate scaled image dimensions
    const imgHeight = (canvas.height * contentWidth) / canvas.width;

    const pdf = new jsPDF("p", "mm", "a4");
    const imgData = canvas.toDataURL("image/png");

    let heightLeft = imgHeight;
    let position = marginTop;

    // First page
    pdf.addImage(
      imgData,
      "PNG",
      marginLeft,
      position,
      contentWidth,
      imgHeight,
    );
    heightLeft -= contentHeight;

    // Additional pages
    while (heightLeft > 0) {
      position = marginTop - (imgHeight - heightLeft);
      pdf.addPage();
      pdf.addImage(
        imgData,
        "PNG",
        marginLeft,
        position,
        contentWidth,
        imgHeight,
      );
      heightLeft -= contentHeight;
    }

    const filename = `${personality.name.split(" ")[0]}-conversation-${new Date().toISOString().split("T")[0]}.pdf`;
    pdf.save(filename);
  } finally {
    document.body.removeChild(container);
  }
}

/**
 * Export entire conversation to Excel
 */
export async function exportConversationToExcel(
  messages: ChatMessage[],
  chatTitle: string,
  botType: BotType,
): Promise<void> {
  // Dynamic import to avoid SSR issues
  const ExcelJS = await import("exceljs");
  const personality = BOT_PERSONALITIES[botType];
  const date = new Date().toLocaleDateString();

  // Create workbook and worksheet
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet("Conversation");

  // Add header information
  worksheet.addRow(["Conversation Export"]);
  worksheet.addRow([`Title: ${chatTitle}`]);
  worksheet.addRow([`Executive: ${personality.name}`]);
  worksheet.addRow([`Date: ${date}`]);
  worksheet.addRow([]); // Empty row

  // Add column headers
  worksheet.addRow(["Role", "Speaker", "Message", "Timestamp"]);

  // Style header row
  const headerRowNum = 6;
  const headerRow = worksheet.getRow(headerRowNum);
  headerRow.font = { bold: true };
  headerRow.fill = {
    type: "pattern",
    pattern: "solid",
    fgColor: { argb: "FFE0E0E0" },
  };

  // Set column widths
  worksheet.columns = [
    { key: "role", width: 12 },
    { key: "speaker", width: 20 },
    { key: "message", width: 80 },
    { key: "timestamp", width: 24 },
  ];

  // Add message data
  for (const message of messages) {
    const textContent = message.parts
      ?.filter((part) => part.type === "text")
      .map((part) => part.text)
      .join("\n")
      .trim();

    if (!textContent) continue;

    const isUser = message.role === "user";
    const msgBotType = (message.metadata?.botType as BotType) || botType;
    const msgPersonality = BOT_PERSONALITIES[msgBotType];

    // Use message metadata createdAt if available, fallback to current time
    const timestamp = message.metadata?.createdAt || new Date().toISOString();

    worksheet.addRow([
      message.role,
      isUser ? "You" : msgPersonality.name,
      textContent,
      timestamp,
    ]);
  }

  // Enable text wrapping for message column
  worksheet.getColumn(3).alignment = { wrapText: true, vertical: "top" };

  // Generate buffer and trigger download
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], {
    type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  });
  const url = URL.createObjectURL(blob);

  const filename = `${personality.name.split(" ")[0]}-conversation-${new Date().toISOString().split("T")[0]}.xlsx`;
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

export function escapeHtml(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

/**
 * Convert markdown formatting to HTML for PDF rendering.
 * Handles bold, italic, inline code, strikethrough, links, and headers.
 */
export function markdownToHtml(text: string): string {
  // First escape HTML entities
  let result = escapeHtml(text);

  // Convert markdown to HTML (order matters - process more specific patterns first)

  // Headers (h1-h3) - must be at start of line
  result = result.replace(/^### (.+)$/gm, '<h3 style="font-size: 16px; font-weight: 600; margin: 12px 0 8px 0;">$1</h3>');
  result = result.replace(/^## (.+)$/gm, '<h2 style="font-size: 18px; font-weight: 600; margin: 16px 0 8px 0;">$1</h2>');
  result = result.replace(/^# (.+)$/gm, '<h1 style="font-size: 20px; font-weight: 700; margin: 20px 0 10px 0;">$1</h1>');

  // Bold + Italic (***text*** or ___text___)
  result = result.replace(/\*\*\*([^*]+)\*\*\*/g, '<strong><em>$1</em></strong>');
  result = result.replace(/___([^_]+)___/g, '<strong><em>$1</em></strong>');

  // Bold (**text** or __text__)
  result = result.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  result = result.replace(/__([^_]+)__/g, '<strong>$1</strong>');

  // Italic (*text* or _text_) - be careful not to match underscores in words
  result = result.replace(/\*([^*\n]+)\*/g, '<em>$1</em>');
  result = result.replace(/(?<![a-zA-Z0-9])_([^_\n]+)_(?![a-zA-Z0-9])/g, '<em>$1</em>');

  // Strikethrough (~~text~~)
  result = result.replace(/~~([^~]+)~~/g, '<del>$1</del>');

  // Inline code (`code`) - use escaped backticks since we already escaped HTML
  result = result.replace(/`([^`]+)`/g, '<code style="background: #f0f0f0; padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 13px;">$1</code>');

  // Links [text](url) - URL is already HTML-escaped
  result = result.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" style="color: #2563eb; text-decoration: underline;">$1</a>');

  // Bullet lists (- item or * item)
  result = result.replace(/^[\-\*] (.+)$/gm, '<li style="margin-left: 20px;">$1</li>');

  // Numbered lists (1. item)
  result = result.replace(/^\d+\. (.+)$/gm, '<li style="margin-left: 20px;">$1</li>');

  // Blockquotes (> text)
  result = result.replace(/^&gt; (.+)$/gm, '<blockquote style="border-left: 3px solid #d1d5db; padding-left: 12px; color: #6b7280; margin: 8px 0;">$1</blockquote>');

  // Horizontal rules (--- or ***)
  result = result.replace(/^(---|\*\*\*)$/gm, '<hr style="border: none; border-top: 1px solid #e5e7eb; margin: 16px 0;">');

  return result;
}
