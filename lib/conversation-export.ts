import DOMPurify from "dompurify";
import { BOT_PERSONALITIES, type BotType } from "@/lib/bot-personalities";
import type { ChatMessage } from "@/lib/types";

/**
 * Export entire conversation to PDF
 */
export async function exportConversationToPDF(
  messages: ChatMessage[],
  chatTitle: string,
  botType: BotType,
): Promise<void> {
  const { default: html2canvas } = await import("html2canvas");
  const { default: jsPDF } = await import("jspdf");

  const personality = BOT_PERSONALITIES[botType];
  const date = new Date().toLocaleDateString();

  // Create container for rendering
  const container = document.createElement("div");
  container.style.cssText = `
    position: absolute;
    left: -9999px;
    width: 800px;
    padding: 40px;
    background: white;
    font-family: system-ui, -apple-system, sans-serif;
  `;

  // Build HTML content
  let html = `
    <div style="margin-bottom: 32px; padding-bottom: 20px; border-bottom: 2px solid #e5e5e5;">
      <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">
        ${personality.avatar ? `<img src="${personality.avatar}" style="width: 64px; height: 64px; border-radius: 50%;" crossorigin="anonymous" />` : ""}
        <div>
          <h1 style="margin: 0; font-size: 24px; color: #1a1a1a;">${chatTitle}</h1>
          <p style="margin: 4px 0 0 0; color: #666; font-size: 14px;">
            Conversation with ${personality.name} • ${date}
          </p>
        </div>
      </div>
    </div>
  `;

  // Add messages
  for (const message of messages) {
    const isUser = message.role === "user";
    const textContent = message.parts
      ?.filter((part) => part.type === "text")
      .map((part) => part.text)
      .join("\n")
      .trim();

    if (!textContent) continue;

    const msgBotType = (message.metadata?.botType as BotType) || botType;
    const msgPersonality = BOT_PERSONALITIES[msgBotType];

    html += `
      <div style="margin-bottom: 24px; padding: 16px; border-radius: 12px; background: ${isUser ? "#f5f5f5" : "#fef2f2"};">
        <div style="font-weight: 600; font-size: 14px; color: ${isUser ? "#333" : "#b91c1c"}; margin-bottom: 8px;">
          ${isUser ? "You" : msgPersonality.name}
        </div>
        <div style="line-height: 1.6; white-space: pre-wrap; color: #1a1a1a; font-size: 14px;">
          ${markdownToHtml(textContent)}
        </div>
      </div>
    `;
  }

  // Footer
  html += `
    <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e5e5; color: #999; font-size: 12px; text-align: center;">
      Generated by Alecci Media AI • ${date}
    </div>
  `;

  // Sanitize HTML with DOMPurify to prevent XSS from user-generated content
  container.innerHTML = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      "div",
      "span",
      "p",
      "h1",
      "h2",
      "h3",
      "strong",
      "em",
      "code",
      "del",
      "a",
      "li",
      "blockquote",
      "hr",
      "img",
      "table",
      "thead",
      "tbody",
      "tr",
      "th",
      "td",
    ],
    ALLOWED_ATTR: ["style", "src", "href", "crossorigin"],
  });
  document.body.appendChild(container);

  // Wait for images to load
  await new Promise((resolve) => setTimeout(resolve, 500));

  try {
    const canvas = await html2canvas(container, {
      scale: 2,
      useCORS: true,
      logging: false,
    });

    // A4 dimensions in mm
    const pageWidth = 210;
    const pageHeight = 297;

    // Margins in mm
    const marginLeft = 15;
    const marginRight = 15;
    const marginTop = 20;
    const marginBottom = 20;

    // Content area dimensions
    const contentWidth = pageWidth - marginLeft - marginRight;
    const contentHeight = pageHeight - marginTop - marginBottom;

    // Calculate scaled image dimensions
    const imgHeight = (canvas.height * contentWidth) / canvas.width;

    const pdf = new jsPDF("p", "mm", "a4");
    const imgData = canvas.toDataURL("image/png");

    let heightLeft = imgHeight;
    let position = marginTop;

    // First page
    pdf.addImage(
      imgData,
      "PNG",
      marginLeft,
      position,
      contentWidth,
      imgHeight,
    );
    heightLeft -= contentHeight;

    // Additional pages
    while (heightLeft > 0) {
      position = marginTop - (imgHeight - heightLeft);
      pdf.addPage();
      pdf.addImage(
        imgData,
        "PNG",
        marginLeft,
        position,
        contentWidth,
        imgHeight,
      );
      heightLeft -= contentHeight;
    }

    const filename = `${personality.name.split(" ")[0]}-conversation-${new Date().toISOString().split("T")[0]}.pdf`;
    pdf.save(filename);
  } finally {
    document.body.removeChild(container);
  }
}

/**
 * Export entire conversation to Excel
 */
export async function exportConversationToExcel(
  messages: ChatMessage[],
  chatTitle: string,
  botType: BotType,
): Promise<void> {
  // Dynamic import to avoid SSR issues
  const ExcelJS = await import("exceljs");
  const personality = BOT_PERSONALITIES[botType];
  const date = new Date().toLocaleDateString();

  // Create workbook and worksheet
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet("Conversation");

  // Add header information
  worksheet.addRow(["Conversation Export"]);
  worksheet.addRow([`Title: ${chatTitle}`]);
  worksheet.addRow([`Executive: ${personality.name}`]);
  worksheet.addRow([`Date: ${date}`]);
  worksheet.addRow([]); // Empty row

  // Add column headers
  worksheet.addRow(["Role", "Speaker", "Message", "Timestamp"]);

  // Style header row
  const headerRowNum = 6;
  const headerRow = worksheet.getRow(headerRowNum);
  headerRow.font = { bold: true };
  headerRow.fill = {
    type: "pattern",
    pattern: "solid",
    fgColor: { argb: "FFE0E0E0" },
  };

  // Set column widths
  worksheet.columns = [
    { key: "role", width: 12 },
    { key: "speaker", width: 20 },
    { key: "message", width: 80 },
    { key: "timestamp", width: 24 },
  ];

  // Add message data
  for (const message of messages) {
    const textContent = message.parts
      ?.filter((part) => part.type === "text")
      .map((part) => part.text)
      .join("\n")
      .trim();

    if (!textContent) continue;

    const isUser = message.role === "user";
    const msgBotType = (message.metadata?.botType as BotType) || botType;
    const msgPersonality = BOT_PERSONALITIES[msgBotType];

    // Use message metadata createdAt if available, fallback to current time
    const timestamp = message.metadata?.createdAt || new Date().toISOString();

    worksheet.addRow([
      message.role,
      isUser ? "You" : msgPersonality.name,
      textContent,
      timestamp,
    ]);
  }

  // Enable text wrapping for message column
  worksheet.getColumn(3).alignment = { wrapText: true, vertical: "top" };

  // Generate buffer and trigger download
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], {
    type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  });
  const url = URL.createObjectURL(blob);

  const filename = `${personality.name.split(" ")[0]}-conversation-${new Date().toISOString().split("T")[0]}.xlsx`;
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

export function escapeHtml(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

/**
 * Convert markdown formatting to HTML for PDF rendering.
 * Handles tables, bold, italic, inline code, strikethrough, links, and headers.
 */
export function markdownToHtml(text: string): string {
  // Process tables BEFORE escaping HTML (tables use | characters)
  let result = processMarkdownTables(text);

  // Escape HTML entities for non-table content
  result = escapeHtmlPreservingTables(result);

  // Convert markdown to HTML (order matters - process more specific patterns first)

  // Headers (h1-h3) - must be at start of line
  result = result.replace(/^### (.+)$/gm, '<h3 style="font-size: 16px; font-weight: 600; margin: 12px 0 8px 0;">$1</h3>');
  result = result.replace(/^## (.+)$/gm, '<h2 style="font-size: 18px; font-weight: 600; margin: 16px 0 8px 0;">$1</h2>');
  result = result.replace(/^# (.+)$/gm, '<h1 style="font-size: 20px; font-weight: 700; margin: 20px 0 10px 0;">$1</h1>');

  // Bold + Italic (***text*** or ___text___)
  result = result.replace(/\*\*\*([^*]+)\*\*\*/g, '<strong><em>$1</em></strong>');
  result = result.replace(/___([^_]+)___/g, '<strong><em>$1</em></strong>');

  // Bold (**text** or __text__)
  result = result.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  result = result.replace(/__([^_]+)__/g, '<strong>$1</strong>');

  // Italic (*text* or _text_) - be careful not to match underscores in words
  result = result.replace(/\*([^*\n]+)\*/g, '<em>$1</em>');
  result = result.replace(/(?<![a-zA-Z0-9])_([^_\n]+)_(?![a-zA-Z0-9])/g, '<em>$1</em>');

  // Strikethrough (~~text~~)
  result = result.replace(/~~([^~]+)~~/g, '<del>$1</del>');

  // Inline code (`code`) - use escaped backticks since we already escaped HTML
  result = result.replace(/`([^`]+)`/g, '<code style="background: #f0f0f0; padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 13px;">$1</code>');

  // Links [text](url) - URL is already HTML-escaped
  result = result.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" style="color: #2563eb; text-decoration: underline;">$1</a>');

  // Bullet lists (- item or * item) - only match if not part of a table separator
  result = result.replace(/^[\-\*] (.+)$/gm, '<li style="margin-left: 20px;">$1</li>');

  // Numbered lists (1. item)
  result = result.replace(/^\d+\. (.+)$/gm, '<li style="margin-left: 20px;">$1</li>');

  // Blockquotes (> text)
  result = result.replace(/^&gt; (.+)$/gm, '<blockquote style="border-left: 3px solid #d1d5db; padding-left: 12px; color: #6b7280; margin: 8px 0;">$1</blockquote>');

  // Horizontal rules (--- or ***) - only standalone lines with just dashes/asterisks
  // This regex ensures we don't match table separators or content with dashes
  result = result.replace(/^-{3,}$/gm, '<hr style="border: none; border-top: 1px solid #e5e7eb; margin: 16px 0;">');
  result = result.replace(/^\*{3,}$/gm, '<hr style="border: none; border-top: 1px solid #e5e7eb; margin: 16px 0;">');

  return result;
}

/**
 * Process markdown tables into HTML tables with styling
 */
function processMarkdownTables(text: string): string {
  const lines = text.split("\n");
  const result: string[] = [];
  let i = 0;

  while (i < lines.length) {
    const line = lines[i];

    // Check if this could be a table header row (contains |)
    if (line.includes("|") && i + 1 < lines.length) {
      const nextLine = lines[i + 1];

      // Check if next line is a separator row (contains | and -)
      if (nextLine && /^\|?[\s\-:|]+\|?$/.test(nextLine) && nextLine.includes("-")) {
        // This is likely a table, collect all table rows
        const tableLines: string[] = [line];
        let j = i + 1;

        // Skip separator line
        j++;

        // Collect data rows
        while (j < lines.length && lines[j].includes("|")) {
          tableLines.push(lines[j]);
          j++;
        }

        // Convert to HTML table
        const tableHtml = convertTableToHtml(tableLines);
        result.push(tableHtml);
        i = j;
        continue;
      }
    }

    result.push(line);
    i++;
  }

  return result.join("\n");
}

/**
 * Convert table lines to HTML table
 */
function convertTableToHtml(lines: string[]): string {
  if (lines.length === 0) return "";

  const tableStyle = `
    border-collapse: collapse;
    width: 100%;
    margin: 16px 0;
    font-size: 14px;
  `.replace(/\s+/g, " ").trim();

  const headerCellStyle = `
    border: 1px solid #d1d5db;
    padding: 10px 12px;
    background: #f3f4f6;
    font-weight: 600;
    text-align: left;
  `.replace(/\s+/g, " ").trim();

  const cellStyle = `
    border: 1px solid #d1d5db;
    padding: 10px 12px;
    text-align: left;
  `.replace(/\s+/g, " ").trim();

  // Parse header row
  const headerCells = parseTableRow(lines[0]);
  const headerHtml = headerCells
    .map((cell) => `<th style="${headerCellStyle}">${escapeHtml(cell)}</th>`)
    .join("");

  // Parse data rows (skip the first row which is header)
  const dataRows = lines.slice(1);
  const bodyHtml = dataRows
    .map((row) => {
      const cells = parseTableRow(row);
      const cellsHtml = cells
        .map((cell) => `<td style="${cellStyle}">${escapeHtml(cell)}</td>`)
        .join("");
      return `<tr>${cellsHtml}</tr>`;
    })
    .join("");

  return `<table style="${tableStyle}"><thead><tr>${headerHtml}</tr></thead><tbody>${bodyHtml}</tbody></table>`;
}

/**
 * Parse a markdown table row into cells
 */
function parseTableRow(row: string): string[] {
  // Remove leading/trailing pipes and split by |
  return row
    .replace(/^\|/, "")
    .replace(/\|$/, "")
    .split("|")
    .map((cell) => cell.trim());
}

/**
 * Escape HTML but preserve already-processed table HTML
 */
function escapeHtmlPreservingTables(text: string): string {
  // Split by table tags, escape non-table parts, rejoin
  const parts = text.split(/(<table[\s\S]*?<\/table>)/g);
  return parts
    .map((part) => {
      if (part.startsWith("<table")) {
        return part; // Already processed table HTML
      }
      return escapeHtml(part);
    })
    .join("");
}
